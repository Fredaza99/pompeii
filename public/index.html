<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="50x50" href="images/favicon-32x32.png">
    <link rel="manifest" href="/site.webmanifest">
    <title>Warships Battle Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: url('images/seaback.webp') no-repeat center center fixed;
            background-size: cover;
            animation: oceanWaves 10s infinite alternate ease-in-out; 
        }

        canvas {
            display: block;
        }


          @keyframes fadeIn {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }


   /* üî• Cont√™iner da n√©voa */
/* üî• Cont√™iner da n√©voa */
#fog-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* N√£o interfere com cliques */
    z-index: -1; /* Mant√©m a n√©voa atr√°s dos elementos */
    overflow: hidden; /* Evita qualquer corte estranho */
}

/* üî• Camadas de n√©voa ajustadas */
.fog-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%; /* üî• Faz a n√©voa ser maior que a tela para permitir um movimento mais amplo */
    height: 100%;
    background: url('images/fog.png') center/cover no-repeat; /* üî• Agora cobre toda a tela */
    opacity: 0.15; /* Ajusta a intensidade da n√©voa */
}

/* üî• Anima√ß√£o para a n√©voa se mover suavemente */
@keyframes fogMove {
    from { transform: translateX(0px) translateY(0px) scale(1.1); }
    to { transform: translateX(-100px) translateY(50px) scale(1.2); }
}

/* üî• Aplicando anima√ß√µes corrigidas para cada camada */
#fog1 {
    animation: fogMove 5s infinite alternate ease-in-out;
    opacity: 0.25;
}

#fog2 {
    animation: fogMove 5s infinite alternate ease-in-out;
    opacity: 0.2;
}

#fog3 {
    animation: fogMove 3s infinite alternate ease-in-out;
    opacity: 0.15;
}

/* üî• Efeito de dissipa√ß√£o da n√©voa */
.fog-fade-out {
    opacity: 0; 
    transition: opacity 2s ease-out; /* Faz a n√©voa desaparecer suavemente */
}




    </style>
</head>

<body>

<div id="nameContainer" style="
    position: absolute;
    width: 50%;
    max-width: 600px;
    height: 60%;
    max-height: 500px;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    font-size: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    z-index: 1000;
    border-radius: 15px;
    padding: 20px;
    text-align: center;
    box-shadow: 0px 0px 15px rgba(255, 255, 255, 0.2);
    opacity: 0;
    animation: fadeIn 1s ease-out forwards;
">

    <!-- √çcone da caveira POSICIONADO NO TOPO DA CAIXA -->
    <img src="images/skull-pirates-with-sword-illustration.png" alt="Pirate Skull" style="
        width: 200px;
        height: 200px;
        margin-bottom: 10px; /* üî• D√° espa√ßo entre a caveira e o t√≠tulo */
    ">

    <h2 style="margin-top: 20px; margin-bottom: 5px; font-family: 'Pirata One', cursive; font-size: 30px;">
        Choose Your Nick
    </h2>

    <input type="text" id="playerNameInput"  maxlength="12" style="
        padding: 15px;
        font-size: 16px;
        margin-bottom: 10px;
        margin-top: 20px;
        width: 80%;
        text-align: center;
        border: none;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        outline: none;
        box-shadow: inset 0px 0px 5px rgba(255, 255, 255, 0.2);
    ">

    <button onclick="setPlayerName()" style="
        padding: 15px 60px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        margin-top: 30px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        border-radius: 8px;
        transition: 0.3s;
    " onmouseover="this.style.background='rgba(255, 255, 255, 0.4)'"
        onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
        Play
    </button>
</div>

<div id="fog-container">
    <div class="fog-layer" id="fog1"></div>
    <div class="fog-layer" id="fog2"></div>
    <div class="fog-layer" id="fog3"></div>
</div>



    <canvas id="gameCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.js"></script>

    <script>
    const socket = io("http://localhost:3000");



        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let shipImage = new Image();
        shipImage.src = "/images/navio_spritesheet.png";
        let healthIcon = new Image();
        healthIcon.src = "/images/rei.gif"; // Coloque o caminho correto do seu √≠cone de vida


        const SPRITE_WIDTH = 83;
        const SPRITE_HEIGHT = 85;
        const impacts = [];

        let animationInterval = null;
        let lastDirection = null;
        let canShoot = true;
        let ship = null;
        let isMoving = false; 
        let lastEmitTime = 0;
        let selectedTarget = null; // üî• Define o alvo inicialmente como nulo




        let ships = {}; 
        let projectiles = [];


        function getFrameIndex(angle) {
            if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
                return 3; // Nordeste (NE)
            } else if (angle >= Math.PI / 4 && angle < 3 * Math.PI / 4) {
                return 0; // Noroeste (NO)
            } else if (angle >= -3 * Math.PI / 4 && angle < -Math.PI / 4) {
                return 1; // Sudeste (SE)
            } else {
                return 2; // Sudoeste (SO)
            }
        }

        function animateCardinalDirections(direction) {
            if (animationInterval) clearInterval(animationInterval);

            let frames = [];
            if (direction === "N") frames = [1, 2]; // Norte alterna entre SE e SO
            else if (direction === "S") frames = [0, 3]; // Sul alterna entre NO e NE
            else if (direction === "L") frames = [3, 1]; // Leste alterna entre NE e SE
            else if (direction === "O") frames = [0, 2]; // Oeste alterna entre NO e SO

            let currentFrame = 0;
            animationInterval = setInterval(() => {
                ship.frameIndex = frames[currentFrame];
                currentFrame = (currentFrame + 1) % 2;
            }, 180);
        }

   socket.on("currentPlayers", (serverPlayers) => {
        ships = serverPlayers;
        console.log("Recebendo jogadores do servidor:", ships); // Depura√ß√£o
    });


socket.on("newPlayer", (player) => {
    ships[player.id] = player;
});

    socket.on("setInitialPosition", (player) => {
            console.log("üö¢ Recebendo posi√ß√£o inicial do servidor:", player.x, player.y);

            ship = {
                x: player.x,
                y: player.y,
                targetX: player.x,
                targetY: player.y,
                speed: 2.4,
                frameIndex: 0
            };

            // üî• Somente agora come√ßamos a renderizar o jogo
            requestAnimationFrame(drawShips);
            requestAnimationFrame(moveShip);
        });



    socket.on("updatePlayer", (player) => {
        if (ships[player.id]) {
            ships[player.id] = player;
        }
    });


socket.on("removePlayer", (playerId) => {
    delete ships[playerId];
});


        socket.on("newProjectile", (projectile) => {
                if (!projectile || projectile.x === undefined || projectile.y === undefined) {
                    console.error("‚ùå Proj√©til recebido com dados inv√°lidos!", projectile);
                    return;
                }

                // üî• Garante que o √¢ngulo esteja presente para evitar proj√©teis parados
                if (projectile.angle === undefined) {
                    console.warn("‚ö†Ô∏è Proj√©til recebido sem √¢ngulo! Definindo padr√£o.");
                    projectile.angle = Math.atan2(projectile.velocityY, projectile.velocityX);
                }

                projectiles.push(projectile);
            });



     function drawShips() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let id in ships) {
                let player = ships[id];
                if (!player) continue;

                ctx.save();
                ctx.translate(player.x, player.y);

                let spriteX = (player.frameIndex || 0) * SPRITE_WIDTH;

                // üî• Desenha o navio
                ctx.drawImage(
                    shipImage,
                    spriteX, 0, SPRITE_WIDTH, SPRITE_HEIGHT,
                    -SPRITE_WIDTH / 2, -SPRITE_HEIGHT / 2, SPRITE_WIDTH, SPRITE_HEIGHT
                );

                ctx.restore();

                    let healthPercentage = player.health / 100;
                let barWidth = 100;
                let barHeight = 3;
                let barY = player.y + 60; // Ajuste de posi√ß√£o vertical da barra
                
                let iconSize = 22; // Ajuste o tamanho conforme necess√°rio
                let iconX = player.x - (barWidth / 2) - iconSize - 5; // Posiciona √† esquerda da barra
                let iconY = barY - (iconSize / 4); 

                ctx.drawImage(healthIcon, iconX, iconY, iconSize, iconSize); // Desenha o √≠cone

                ctx.fillStyle = "red";
                ctx.fillRect(player.x - barWidth / 2, player.y + 67, barWidth, barHeight); // Fundo da barra

                ctx.fillStyle = "green";
                ctx.fillRect(player.x - barWidth / 2, player.y + 67, barWidth * healthPercentage, barHeight); // Vida atual
            
                        // üî• Exibir nome do jogador acima da barra de vida
                if (player.name) {
                    ctx.fillStyle = "white";
                    ctx.font = "14px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(player.name, player.x, barY - -2); // Nome acima da barra de vida
                }
            }

            drawProjectiles();
            drawImpacts();
            

            requestAnimationFrame(drawShips);
        }

        function setPlayerName() {
                const input = document.getElementById("playerNameInput");
                const playerName = input.value.trim();

                if (playerName === "") {
                    alert("Por favor, digite um nome!");
                    return;
                }

                socket.emit("setName", playerName); // üî• Envia o nome para o servidor

                document.getElementById("nameContainer").style.display = "none"; // Esconde a tela de nome
                
                let fogContainer = document.getElementById("fog-container");
            
                fogContainer.classList.add("fog-fade-out"); // Aplica a classe CSS de fade-out

            // üî• Remove a n√©voa do DOM ap√≥s a transi√ß√£o
            setTimeout(() => {
                fogContainer.remove();
            }, 2000); // Tempo da anima√ß√£o de fade-out
        }


            socket.on("setName", (name) => {
                    if (players[socket.id]) {
                        players[socket.id].name = name;
                        io.emit("updatePlayer", { id: socket.id, ...players[socket.id] }); // üî• Envia atualiza√ß√£o do nome para todos
                    }
                });
                

                   




     function getClickedPlayer(event) {
            let clickX = event.clientX;
            let clickY = event.clientY;

            for (let id in ships) {
                if (id !== socket.id) { // Evita selecionar a si mesmo
                    let player = ships[id];

                    // Define √°rea clic√°vel do navio
                    let shipLeft = player.x - SPRITE_WIDTH / 2;
                    let shipRight = player.x + SPRITE_WIDTH / 2;
                    let shipTop = player.y - SPRITE_HEIGHT / 2;
                    let shipBottom = player.y + SPRITE_HEIGHT / 2;

                    if (clickX >= shipLeft && clickX <= shipRight && clickY >= shipTop && clickY <= shipBottom) {
                        return id; // Retorna o ID do inimigo clicado
                    }
                }
            }
            return null; // Retorna nulo se nenhum inimigo foi clicado
        }






    function moveShip() {
        if (!ship) return; // üî• Apenas checa se ship existe, mas n√£o bloqueia a fun√ß√£o

            isMoving = true; // üî• Marca que a fun√ß√£o est√° rodando para evitar chamadas duplicadas

            function step() {
                if (!ship) {
                    isMoving = false;
                    return;
                }

                let dx = ship.targetX - ship.x;
                let dy = ship.targetY - ship.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > ship.speed) { // üî• Se ainda n√£o chegou ao destino
                    ship.x += (dx / distance) * ship.speed;
                    ship.y += (dy / distance) * ship.speed;
                    let angle = Math.atan2(dy, dx);

                    // üî• Atualiza a dire√ß√£o do navio
                    let newDirection = null;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        newDirection = dx > 0 ? "L" : "O";
                    } else {
                        newDirection = dy > 0 ? "S" : "N";
                    }

                    if (newDirection !== lastDirection) {
                        lastDirection = newDirection;
                        if (!["N", "S", "L", "O"].includes(newDirection)) {
                            clearInterval(animationInterval);
                            ship.frameIndex = getFrameIndex(angle);
                        } else {
                            animateCardinalDirections(newDirection);
                        }
                    }

                    // üî• Envia a posi√ß√£o atualizada ao servidor
                    socket.emit("move", {
                        x: ship.x,
                        y: ship.y,
                        angle: angle,
                        frameIndex: ship.frameIndex
                    });

                    requestAnimationFrame(step); // üî• Continua movendo at√© chegar no destino
                } else {
                    isMoving = false; // üî• Para o movimento quando chegar ao destino
                }
            }

            requestAnimationFrame(step); // üî• Inicia o movimento corretamente
        }




      document.addEventListener("click", (event) => {
            if (!ship) return;

            let rect = canvas.getBoundingClientRect();
            let correctedX = event.clientX - rect.left;
            let correctedY = event.clientY - rect.top;

            // üî• Verifica se o clique foi em um inimigo
            let clickedEnemy = getClickedPlayer(event);

            if (clickedEnemy) {
                selectedTarget = clickedEnemy; // üî• Define o alvo do ataque
                console.log(`üéØ Inimigo selecionado: ${selectedTarget}`);
            } else {
                selectedTarget = null; // üî• Remove a sele√ß√£o caso clique no mar
                ship.targetX = correctedX;
                ship.targetY = correctedY;

                // üî• Se o navio n√£o estiver se movendo, inicia a movimenta√ß√£o
                if (!isMoving) {
                    moveShip();
                }
            }
        });







       document.addEventListener("keydown", (event) => {
            if (event.code === "Space" && selectedTarget && canShoot) {
                socket.emit("shoot", { targetId: selectedTarget });
                canShoot = false;

                // üî• Tempo de recarga para evitar spam de tiros
                setTimeout(() => { canShoot = true; }, 1000);
            }
        });



                 function drawLuminousBall(ctx, x, y) {
                        if (!isFinite(x) || !isFinite(y)) {
                            console.warn("‚ö†Ô∏è Proj√©til com posi√ß√£o inv√°lida detectado:", x, y);
                            return; // üî• Evita desenhar proj√©teis inv√°lidos
                        }

                        let gradient = ctx.createRadialGradient(x, y, 2, x, y, 10);
                        gradient.addColorStop(0, "rgba(255, 255, 0, 1)"); // Amarelo brilhante
                        gradient.addColorStop(0.5, "rgba(255, 165, 0, 0.8)"); // Laranja suave
                        gradient.addColorStop(1, "rgba(255, 0, 0, 0)"); // Dissipa√ß√£o vermelha

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }


                        // Cria um efeito de impacto ao atingir o alvo
                        function createImpactEffect(x, y) {
                            impacts.push({ x, y, size: 15, opacity: 1 });
                        }

                        // Atualiza e desenha os impactos
                        function drawImpacts() {
                            impacts.forEach((impact, index) => {
                                ctx.fillStyle = `rgba(255, 140, 0, ${impact.opacity})`;
                                ctx.beginPath();
                                ctx.arc(impact.x, impact.y, impact.size, 0, Math.PI * 2);
                                ctx.fill();

                                impact.size += 2;
                                impact.opacity -= 0.05;

                                if (impact.opacity <= 0) {
                                    impacts.splice(index, 1);
                                }
                            });

                            requestAnimationFrame(drawImpacts);
                        }

                        // Atualiza a posi√ß√£o dos proj√©teis
                        function updateProjectiles() {
                            for (let i = projectiles.length - 1; i >= 0; i--) {
                                let p = projectiles[i];

                                p.x += p.velocityX;
                                p.y += p.velocityY;

                                // Verifica se o proj√©til atingiu o alvo
                                let dx = p.targetX - p.x;
                                let dy = p.targetY - p.y;
                                let distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance < 5) { // üî• Quando atinge o alvo
                                    createImpactEffect(p.targetX, p.targetY);
                                    projectiles.splice(i, 1); // Remove o proj√©til
                                }
                            }

                            requestAnimationFrame(updateProjectiles);
                        }

                        // Renderiza os proj√©teis
                        function drawProjectiles() {
                            projectiles.forEach((p) => drawLuminousBall(ctx, p.x, p.y));
                            requestAnimationFrame(drawProjectiles);
                        }

                        // Recebe os proj√©teis do servidor
                        socket.on("newProjectile", (data) => {
                            const angle = Math.atan2(data.targetY - data.startY, data.targetX - data.startX);
                            const speed = 5;

                            const projectile = {
                                x: data.startX,
                                y: data.startY,
                                velocityX: Math.cos(angle) * speed,
                                velocityY: Math.sin(angle) * speed,
                                targetX: data.targetX,
                                targetY: data.targetY
                            };

                            projectiles.push(projectile);
                        });

                        // Inicia os loops de anima√ß√£o
                        updateProjectiles();
                        drawProjectiles();
                        drawImpacts();
                



      shipImage.onload = () => {
            if (ship) {
                drawShips();
                moveShip();
            }
        };


         function typePlaceholder(text, speed) {
                let input = document.getElementById("playerNameInput");
                let i = 0;
                function typing() {
                    if (i < text.length) {
                        input.placeholder += text.charAt(i);
                        i++;
                        setTimeout(typing, speed);
                    }
                }
                setTimeout(typing, 400);
            }

            typePlaceholder("Enter your pirate name...", 100);


    </script>
</body>

</html>